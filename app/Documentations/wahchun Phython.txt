#!/usr/bin/env python

"""Module for event-related json replies.
"""

import datetime
import logging

from livejsonapi.views.helpers.common import get_parameter_from_request as gpfr
from livejsonapi.views.helpers.common import get_id_as_long
from livejsonapi.views.helpers.common import respond
from google.appengine.ext import db
from google.appengine.api import urlfetch
from google.appengine.api import mail

from django.utils import simplejson as json
from django.http import HttpResponse

from singpath import models as models
from livejsonapi.models import prefetch_refprops

def to_json(obj, theClass, attributes):
        res = {}
        #logging.info()
        for key in attributes:
            prop = getattr(theClass, key)
            if isinstance(prop, db.ReferenceProperty):
                k = prop.get_value_for_datastore(obj)
                res[key] = k.id() if k else None
            else:
                res[key] = getattr(obj, key)
        if obj.key(): res['id'] = obj.key().id()
        return res

def current_player_events(request):
    currentPlayer = models.Player.get_the_current_player()
    eventRegistrationParameters = ['player','event','status','registered','plusone','created']
    
    theJson = {"type":"events","events":[]}
    for eventRegistration in models.EventRegistration.all().filter('player = ', currentPlayer).fetch(10):
            er = to_json(eventRegistration,models.EventRegistration, eventRegistrationParameters)
            theJson[events].append(er)
        
    dthandler = lambda obj: obj.isoformat() if isinstance(obj, datetime.datetime) else None    
    content = json.dumps(theJson,default=dthandler)
    response = HttpResponse(content, mimetype='application/json')
    return response

#POST /jsonapi/eventregistration/5308925893148672?action=participate
def eventregistration(request,eventID=None):
    currentPlayer = models.Player.get_the_current_player()
    eventRegistrationParameters = ['player','event','status','plusone','created']
        
    if request.method == 'POST':  
        if not currentPlayer:
            return respond(request, {'error': 'Player not signed in'})

        if not eventID:
            return respond(request, {'error': 'No eventID passed in'})
        
        theID = int(eventID)
        
        event = models.Event.get_by_id(theID)
        if not event:
            return respond(request, {'error': 'Invalid eventID'})
        
        var = json.loads(request.raw_post_data)        
        if not var.has_key("status"):
            return respond(request, {'error': 'No status passed'})
        
        eventRegistration = models.EventRegistration.all().filter('player = ', currentPlayer).filter("event = ",event).get()
        if eventRegistration:
            eventRegistration.status = var["status"]
            eventRegistration.put()
            
        else:
            eventRegistration = models.EventRegistration(player=currentPlayer,
                                                         event=event,
                                                         status=var["status"])
            eventRegistration.put()
            
        theJson = to_json(eventRegistration, models.EventRegistration, eventRegistrationParameters)

    #For GET's return 200 registrations list. 
    #Laster we need to look at the passed in parameters to parse the list or page through results
    else:
        theJson = {"type":"eventregistrations","eventregistrations":[]}
        for eventRegistration in models.EventRegistration.all().fetch(200):
            er = to_json(eventRegistration,models.EventRegistration, eventRegistrationParameters)
            theJson["eventregistrations"].append(er)
        
    dthandler = lambda obj: obj.isoformat() if isinstance(obj, datetime.datetime) else None    
    content = json.dumps(theJson,default=dthandler)
    response = HttpResponse(content, mimetype='application/json')
    return response
  
  
def get_event_ranking(event,lockranking=False,bysolved=False):
    result = {}
    currentPlayer = models.Player.get_the_current_player()
    currentPlayerID = 0
    if currentPlayer:
      currentPlayerID = currentPlayer.key().id()
      
    ers = models.EventRegistration.all().filter('event', event).filter('status','participate').fetch(1000)
    ers = prefetch_refprops(ers, models.EventRegistration.player)

    result['resgistered'] = len(ers)
    ranking = []
    for er in ers:
            entry = {}
            entry['playerid'] = er.player.key().id()
            entry['nickname'] = er.player.nickname
            #if er.rankatcutoff:
            entry['rankatcutoff'] = er.rankatcutoff
            #if er.solvedatcutoff:
            entry['solvedatcutoff'] = er.solvedatcutoff
            #if er.sentrsvp:
            entry['sentrsvp'] = er.sentrsvp
            #if er.rsvp: #None is an option
            entry['rsvp'] = er.rsvp
            
            if entry['playerid'] == currentPlayerID:
              entry['isCurrentPlayer'] = True
            else:
              entry['isCurrentPlayer'] = False
              
            psp = models.PlayerSolvedProblem.all().filter('path', event.path).filter('player', er.player).get()
            if psp:
                entry['solvedproblems'] = psp.solved_num
                if psp.highestBadge:
                    entry['highestbadgeurl'] = psp.highestBadge.url
                    entry['highestbadgename'] = psp.highestBadge.name
                    entry['highestbadgedescription'] = psp.highestBadge.description
            else:
                entry['solvedproblems'] = 0
            
            schoolreg = None
            if len(event.schooltypes)>0:
              schoolreg = models.SchoolRegistration.all().filter('player', er.player).filter('schooltype', event.schooltypes[0]).get()

            if schoolreg:
                entry['year'] = schoolreg.year
                entry['schooltype'] = schoolreg.school.schooltype
                entry['subtype'] = schoolreg.school.subtype
                entry['schoolname'] = schoolreg.school.name
                
            else:
                entry['schoolname'] = "No school registered"
                entry['solvedproblems'] = 0 - entry['solvedproblems']
            ranking.append(entry)
    from operator import itemgetter
    newranking = sorted(ranking, key=itemgetter('solvedproblems'), reverse=True)
    
    if event.rankinglocked and not bysolved:
        #Default is 0
        newranking = sorted(ranking, key=itemgetter('rankatcutoff'), reverse=False)
    
    for x in range(len(newranking)):
        newranking[x]["rank"] = x+1
      
    # Update the registration records if locking ranking. 
    if lockranking and not event.rankinglocked:

      for er in ers:
        #Iterate through the registration of each player and update the rank. 
        playerID = er.player.key().id()
        for x in range(len(newranking)):
            if newranking[x]["playerid"] == playerID:
              er.rankatcutoff = newranking[x]["rank"]
              er.solvedatcutoff = newranking[x]["solvedproblems"]
              er.put()
              #newranking[x]["rankatcutoff"] = newranking[x]["rank"]
              #newranking[x]["solvedatcutoff "] = newranking[x]["solvedproblems"]
              
    result['ranking'] = newranking 
    return result

def event(request,eventID=None,lockranking=False):
    eventParameters = ['name','description','cutoff','cutoffdate','rankinglocked','venue','start','latitude','longitude','created']
    currentPlayer = models.Player.get_the_current_player()
    bysolved = request.GET.get("bysolved",None)
    #request.GET.get('section','') # => [39]
    if bysolved:
      bysolved=True
    
    if request.method == 'POST':  
        if not currentPlayer:
            return respond(request, {'error': 'You must be logged in to create or edit events.'})
  
        var = json.loads(request.raw_post_data)

        event = None
        #If there is an event
        if eventID:
            event = models.Event.get_by_id(int(eventID))
            if not event:
                return respond(request, {'error': 'No event with that ID'})
            if event.editor.key().id() != currentPlayer.key().id() and not models.Player.is_current_player_admin() :
                return respond(request, {'error': 'The current player is not the editor for this event.'})
            else:
                    try:
                        if var.has_key("name"):
                            event.name = var["name"]
                        if var.has_key("description"):
                            event.schooltype = var["description"]
                        if var.has_key("venue"):
                            event.subtype = var["venue"]
                        if var.has_key("latitude"):
                            event.latitude = var["latitude"]
                        if var.has_key("longitude"):
                            event.longitude = var["logitude"]  
                        if var.has_key("cutoff"):
                            event.cutoff = var["cutoff"]  
                        if var.has_key("archived"):
                            event.cutoff = var["archived"]  
                        """
                          cutoffdate = db.DateTimeProperty(required=False)
                          start = db.DateTimeProperty(required=False)
                          schooltypes = db.StringListProperty()
                          subtypes = db.StringListProperty()
                          startyears = db.ListProperty(int)
                          path =  db.ReferenceProperty(Path, required=False) 
                        """
                    except Exception, e:
                        error = {'error': e.message}
                        return respond(request, error)
                    
                    event.put()
                    theJson = to_json(event, models.Event, eventParameters)
        #Create a new event
        else:
            try:
                event = models.Event(name = var["name"],
                                     schooltype = var["description"],
                                     subtype = var["venue"],
                                     editor = currentPlayer
                                     )
                event.put()
            except Exception, e:
                error = {'error': e.message}
                return respond(request, error)
        
            theJson = to_json(event, models.Event, eventParameters)

    #If not a POST and a eventID
    elif eventID:
        event = models.Event.get_by_id(int(eventID))
        if not event:
            return respond(request, {'error': 'No such event'})
        

        theJson = to_json(event, models.Event, eventParameters)
        registered = models.EventRegistration.all().filter('event', event).count()
        participating =  models.EventRegistration.all().filter('event', event).filter('status', 'participate').count()
        watching =  models.EventRegistration.all().filter('event', event).filter('status', 'watch').count()
        following =  models.EventRegistration.all().filter('event', event).filter('status', 'follow').count()
        theJson["registered"] = registered
        theJson["participating"] = participating
        theJson["watching"] = watching
        theJson["following"] = following
        if event.path:
            theJson["path"] = event.path.name
        result = get_event_ranking(event,lockranking=lockranking,bysolved=bysolved)
        theJson["ranking"] = result["ranking"]
        #registeredPlayers = models.EventRegistration.all().filter('event', event).filter('status', 'participate').fetch(100)
    #if not a POST and no Event ID return list of events.    
    else:
        theJson = {"type":"events","events":[]}
        for event in models.Event.all():      
            e = to_json(event, models.Event, eventParameters)
            eventRegistration = models.EventRegistration.all().filter('player = ', currentPlayer).filter("event = ",event).get()
            if eventRegistration:
                e["currentPlayerStatus"] = eventRegistration.status
            else:
                e["currentPlayerStatus"] = "Not registered"
            #add registration count
            registered = models.EventRegistration.all().filter('event', event).count()
            participating =  models.EventRegistration.all().filter('event', event).filter('status', 'participate').count()
            watching =  models.EventRegistration.all().filter('event', event).filter('status', 'watch').count()
            following =  models.EventRegistration.all().filter('event', event).filter('status', 'follow').count()
            e["registered"] = registered
            e["participating"] = participating
            e["watching"] = watching
            e["following"] = following
            theJson["events"].append(e)
                
    dthandler = lambda obj: obj.isoformat() if isinstance(obj, datetime.datetime) else None    
    content = json.dumps(theJson,default=dthandler)
    response = HttpResponse(content, mimetype='application/json')
    return response

def lock_event_ranking(request, eventID):
    if not models.Player.is_current_player_admin():
        return respond(request, {'error': 'Only the admin can freeze events'})
    event = models.Event.get_by_id(eventID)
    if not event:
        return respond(request, {'error': 'This is not a valid event.'})
        #return HttpResponse("This is not a valid event.", mimetype='text/plain')
    
    if event.rankinglocked:
        return respond(request, {'error': 'You can not re-lock a rankinglocked event.'})
        #return HttpResponse("You can not freeze a rankinglocked event.", mimetype='text/plain')
    return event(request,eventID=eventID,lockranking=True) 

#catch event registration event response. 
def eventrsvp(request, eventID, playerID,response):
    #/eventID/playerID/response /1/1/1
    currentPlayer = models.Player.get_the_current_player()
    if not currentPlayer:
        return HttpResponse("You need to be logged in to SingPath from this browser to rsvp.", mimetype='text/plain')
    
    event = models.Event.get_by_id(eventID)
    if not event:
        return HttpResponse("This is not a valid event.", mimetype='text/plain')
    
    rsvpplayer = models.Player.get_by_id(playerID)
    if not rsvpplayer:
        return HttpResponse("This is a bad rsvp request. Please contanct the event director.", mimetype='text/plain')
    
    
    #Add messaging to ask the player to login to SingPath from this system and try again. 
    #Check for event
    #Check that the player was sent an invitation for the event. 
    #Update their status
    finalresult = "There was an error with your rsvp. Please contact the event director."
    
    if response==0:
      #Update response to be No
      # TBD
      finalresult = "Thank you for confirming that you will NOT be attending."
    elif response==1:
      #Update response to be Yes
      # TBD
      finalresult = "Thank you for confirming that you will be attending."
    
    response = HttpResponse(finalresult, mimetype='text/plain')
    return response

def send_email(to,sender,subject, body,cc=[],bcc=[]):
    logging.info('Preparing email')
    message = mail.EmailMessage(
            sender = 'pivotalexpert@gmail.com',
            subject = 'school registered',
            to = to,
            body = body,
            cc=cc,
            bcc=bcc)
    try:
        message.send()
        logging.info('Email successfully sent')
    except Exception, e:
        logging.error('Error while sending email: '+str(e))

def send_event_message(request):
    currentPlayer = models.Player.get_the_current_player()
    if not currentPlayer:
        return respond(request, {'error': 'You must be logged in to send messages.'})
    
    var = json.loads(request.raw_post_data)
    
    if not var.has_key("eventID"):
        return respond(request, {'error': 'No eventID passed.'})      
    
    eventID = int(var["eventID"])
    event = models.Event.get_by_id(eventID)
    if not event:
        return respond(request, {'error': 'No event with that ID'})
    
    if event.editor.key().id() != currentPlayer.key().id() and not models.Player.is_current_player_admin():
        return respond(request, {'error': 'The current player is not the editor for this event.'})
    
    if not var.has_key("playerIDs"):
        return respond(request, {'error': 'No playerIDs passed.'})      
    
    if not var.has_key("messageTitle"):
        return respond(request, {'error': 'No messageTitle passed.'})      
    
    if not var.has_key("messageBody"):
        return respond(request, {'error': 'No messageBody passed.'})      
    
    if not var.has_key("includeRSVP"):
        return respond(request, {'error': 'No includeRSVP passed.'})      
    
    to = ""
    sender = 'pivotalexpert@gmail.com'
    subject = ""
    body = ""
    cc = ['pivotalexpert@gmail.com']
    bcc = ['pivotalexpert@gmail.com']
    for playerID in var["playerIDs"]:
      print playerID
      player = models.Player.get_by_id(playerID)
      to = [player.email]
      send_email(to,sender,subject, body,cc,bcc)
      
    return respond(request, {'error': 'TBD.'})
  
def event_stats(request,eventID=None):
    if not models.Player.is_current_player_admin():
        #pass
        return respond(request, {'error': 'Only the admin can modify events'})
    import datetime
    now = datetime.datetime.now()
    results = ""
    final_players = 0
    final_solved = 0.0
    final_time = 0.0
    final_attempts = 0.0
    
    events = models.Event.all()
    
    if eventID:
      event = models.Event.get_by_id(int(eventID))
      if not event:
        return respond(request, {'error': 'no event with that eventID'})
      events = [event]
    
    for event in events:
        #results += "**** "+ event.name+ " **** created "+ str(event.created)+ " time since start "+ str((now-event.created).days) +"\n"
        ers = models.EventRegistration.all().filter('event = ', event).filter('status =', 'participate').fetch(1000)
        ers = prefetch_refprops(ers, models.EventRegistration.player)

        for er in ers:
          event_players = []
          #Should we add the filter to only look at the tournament path or count all problems solved? 
          grs = models.GameResult.all().filter('player', er.player).filter('game_start > ',event.created).fetch(1000)
          #grs = prefetch_refprops(grs, models.GameResult.player)

          total_time = 0
          total_attempts = 0
          for gr in grs:
            total_time += gr.solve_time
            total_attempts += gr.attempts
          event_players.append({"solved":len(grs), "nickname": er.player.nickname,"email":er.player.email,"total_time":total_time, "total_attempts":total_attempts,"time_playing":(now-er.created).days})
          final_players += 1
          final_solved += len(grs)
          final_time += total_time
          final_attempts += total_attempts
          import operator 
          event_players.sort(key=operator.itemgetter('solved'))
      
          for ep in event_players:
            results += event.name.replace(",","")+"," +str(ep["solved"])+","+ ep["nickname"].replace(",","")+","+ep["email"]+","+str(ep["total_time"])+ ","+str(ep["total_attempts"])+","+str(ep["time_playing"])+","+str(1.0*ep["total_time"]/(3600.0))+"\n"

    header = "Event, Solved Since Registering, Nickname, Email,Time(s), Attempts, Days Since Registering, Hours Played , Days Played\n"
    header2 = str(final_players)+" , "+str(final_solved)+", , "+str(final_time)+", "+str(final_attempts)+", , "+str(final_time/(3600))+","+str(final_time/(3600*24))+"\n"

    finalresult = header+header2+results
    response = HttpResponse(finalresult, mimetype='text/plain')
    return response
  
  